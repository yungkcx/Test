#include "axx.hpp"

using std::cout;
using std::endl;

class MutexLockGuard
{
    std::mutex& mutex_;
public:
    MutexLockGuard(std::mutex& mutex)
        : mutex_(mutex)
    {
        mutex_.lock();
    }
    ~MutexLockGuard()
    {
        mutex_.unlock();
    }
};

class Counter: boost::noncopyable
{
    int64_t value_;
    mutable std::mutex mutex_;
public:
    Counter(): value_(0) {}
    int64_t value() const;
    int64_t getAndIncrese();
    void operator()()
    {
        for (int i = 0; i < 10; ++i) {
            cout << getAndIncrese() << endl;
        }
    }
};

int64_t Counter::value() const
{
    std::lock_guard<std::mutex> lock(mutex_);
    return value_;
}

int64_t Counter::getAndIncrese()
{
    MutexLockGuard lock(mutex_);
    int64_t ret = value_++;
    return ret;
}

class ThreadGuard
{
    std::thread& t_;
public:
    ThreadGuard(std::thread& t) : t_(t) {}
    ~ThreadGuard()
    {
        t_.joinable() ? t_.join() : throw std::logic_error("no thread");
    }
};

class CC {
public:
    virtual void func();
};

class AA : public CC
{
public:
    virtual void func()
    {
        cout << "OKOK" << endl;
    }
};

void hello(CC* c)
{
    c->func();
}

int main()
{
    char t[] = "hello world";
    const char* start = t;
    const char* end = t + strlen(t);
    std::string s(start, end);
    std::basic_string<char> ss(start, end);
    cout << s << endl
         << ss << endl;

    return 0;
}
