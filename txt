#include "bin.h"

#define MAX 10000

void my_echo(int fd, struct sockaddr *cliaddr, socklen_t clilen)
{
    int n;
    char buf[MAX];
    socklen_t len;
    struct sockaddr_storage cli;
    
    n = MAX;
    memcpy(&cli, cliaddr, clilen);
    len = clilen;
    while (1) {
        memset(buf, 0, n);
        n = recvfrom(fd, buf, MAX, 0, (struct sockaddr *) &cli, &len);
        if (n == 0)
            exit(0);
        printf("%d from %s\n", fd, sock_ntop((struct sockaddr *) &cli));
        sendto(fd, buf, n, 0, (struct sockaddr *) &cli, len);
    }
}

int main(int argc, char **argv)
{
    int fd, n;
    const int on = 1;
    sa_family_t family;
    struct ifaddrs *ifaddr, *ifa;
    struct sockaddr_in6 *sin6;
    struct sockaddr_in *sin, wildaddr;

    if (getifaddrs(&ifaddr) < 0)
        error(EXIT_FAILURE, errno, "getifaddrs error");
    if (ifaddr->ifa_addr == NULL)
        error(EXIT_FAILURE, errno, "getifaddrs error");

    ifa = ifaddr;
    do {
        if (ifa->ifa_addr == NULL)
            continue;
        family = ifa->ifa_addr->sa_family;
        if (family == AF_INET6) {
            fd = socket(AF_INET6, SOCK_DGRAM, 0);
            sin6 = (struct sockaddr_in6 *) ifa->ifa_addr;
            sin6->sin6_port = htons(atoi(PORT));
            n = bind(fd, ifa->ifa_addr, sizeof(struct sockaddr_in6));
        } else if (family == AF_INET) {
            fd = socket(AF_INET, SOCK_DGRAM, 0);
            sin = (struct sockaddr_in *) ifa->ifa_addr;
            sin->sin_port = htons(atoi(PORT));
            n = bind(fd, ifa->ifa_addr, sizeof(struct sockaddr_in));
        } else {
            continue;
        }
        if (n < 0) {
            if (errno == EAFNOSUPPORT) {
                continue;
            } else {
                error(0, errno, "bind error: %s", sock_ntop(ifa->ifa_addr));
                continue;
            }                
        }
        printf("bind success: %s on %s\n", sock_ntop(ifa->ifa_addr), ifa->ifa_name);
        if (fork() == 0) {
            my_echo(fd, ifa->ifa_addr,
                        family == AF_INET ? sizeof(struct sockaddr_in) :
                                            sizeof(struct sockaddr_in6)
                   );
            exit(0);
        }
    } while ((ifa = ifa->ifa_next) != NULL);
    freeifaddrs(ifaddr);

    fd = socket(AF_INET, SOCK_DGRAM, 0);
    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
    n = bind(fd, (struct sockaddr *) &wildaddr, sizeof(struct sockaddr_in));
    wildaddr.sin_family = AF_INET;
    wildaddr.sin_port = htons(33333);
    wildaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    if (n < 0)
        error(EXIT_FAILURE, errno, "bind error");
    printf("bind success: %s\n", sock_ntop((struct sockaddr *) &wildaddr));

    if (fork() == 0) {
        my_echo(fd, (struct sockaddr *) &wildaddr, sizeof(wildaddr));
        exit(0);
    }
    while (1)
        sleep(100);

    exit(0);
}
